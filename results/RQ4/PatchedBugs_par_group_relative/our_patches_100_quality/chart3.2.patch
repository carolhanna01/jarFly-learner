--- ./original/org/jfree/data/time/TimeSeries.java	2022-12-21 10:19:24.000000000 +0000
+++ ./variant536/org/jfree/data/time/TimeSeries.java	2022-12-21 23:08:57.000000000 +0000
@@ -185,7 +185,10 @@
     public TimeSeries(Comparable name, String domain, String range) {
         super(name);
         this.domain = domain;
-        this.range = range;
+        {
+			this.range = range;
+			fireSeriesChanged();
+		}
         this.timePeriodClass = null;
         this.data = new java.util.ArrayList();
         this.maximumItemCount = Integer.MAX_VALUE;
@@ -822,39 +825,37 @@
         }
         TimeSeriesDataItem overwritten = null;
         int index = Collections.binarySearch(this.data, item);
-        if (index >= 0) {
-            TimeSeriesDataItem existing
-                    = (TimeSeriesDataItem) this.data.get(index);
-            overwritten = (TimeSeriesDataItem) existing.clone();
-            // figure out if we need to iterate through all the y-values
-            // to find the revised minY / maxY
-            boolean iterate = false;
-            Number oldYN = existing.getValue();
-            double oldY = oldYN != null ? oldYN.doubleValue() : Double.NaN;
-            if (!Double.isNaN(oldY)) {
-                iterate = oldY <= this.minY || oldY >= this.maxY;
-            }
-            existing.setValue(item.getValue());
-            if (iterate) {
-                findBoundsByIteration();
-            }
-            else if (item.getValue() != null) {
-                double yy = item.getValue().doubleValue();
-                this.minY = minIgnoreNaN(this.minY, yy);
-                this.maxY = minIgnoreNaN(this.maxY, yy);
-            }
-        }
-        else {
-            item = (TimeSeriesDataItem) item.clone();
-            this.data.add(-index - 1, item);
-            updateBoundsForAddedItem(item);
-
-            // check if this addition will exceed the maximum item count...
-            if (getItemCount() > this.maximumItemCount) {
-                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);
-                updateBoundsForRemovedItem(d);
-            }
-        }
+        {
+			if (index >= 0) {
+				TimeSeriesDataItem existing = (TimeSeriesDataItem) this.data.get(index);
+				overwritten = (TimeSeriesDataItem) existing.clone();
+				boolean iterate = false;
+				Number oldYN = existing.getValue();
+				double oldY = oldYN != null ? oldYN.doubleValue() : Double.NaN;
+				if (!Double.isNaN(oldY)) {
+					iterate = oldY <= this.minY || oldY >= this.maxY;
+				}
+				existing.setValue(item.getValue());
+				if (iterate) {
+					findBoundsByIteration();
+				} else if (item.getValue() != null) {
+					double yy = item.getValue().doubleValue();
+					this.minY = minIgnoreNaN(this.minY, yy);
+					this.maxY = minIgnoreNaN(this.maxY, yy);
+				}
+			} else {
+				item = (TimeSeriesDataItem) item.clone();
+				this.data.add(-index - 1, item);
+				updateBoundsForAddedItem(item);
+				if (getItemCount() > this.maximumItemCount) {
+					TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);
+					updateBoundsForRemovedItem(d);
+				}
+			}
+			{
+				fireSeriesChanged();
+			}
+		}
         removeAgedItems(false);  // remove old items if necessary, but
                                  // don't notify anyone, because that
                                  // happens next anyway...
@@ -872,23 +873,23 @@
      *                sent to registered listeners IF any items are removed.
      */
     public void removeAgedItems(boolean notify) {
-        // check if there are any values earlier than specified by the history
-        // count...
-        if (getItemCount() > 1) {
-            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();
-            boolean removed = false;
-            while ((latest - getTimePeriod(0).getSerialIndex())
-                    > this.maximumItemAge) {
-                this.data.remove(0);
-                removed = true;
-            }
-            if (removed) {
-                findBoundsByIteration();
-                if (notify) {
-                    fireSeriesChanged();
-                }
-            }
-        }
+        {
+			if (getItemCount() > 1) {
+				long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();
+				boolean removed = false;
+				while ((latest - getTimePeriod(0).getSerialIndex()) > this.maximumItemAge) {
+					this.data.remove(0);
+					removed = true;
+				}
+				if (removed) {
+					findBoundsByIteration();
+					if (notify) {
+						fireSeriesChanged();
+					}
+				}
+			}
+			findBoundsByIteration();
+		}
     }
 
     /**
