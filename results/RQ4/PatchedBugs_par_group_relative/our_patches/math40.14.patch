--- ./original/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java	2022-12-17 10:14:47.000000000 +0000
+++ ./variant608/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java	2022-12-17 18:25:28.000000000 +0000
@@ -125,7 +125,10 @@
         if (maximalOrder < 2) {
             throw new NumberIsTooSmallException(maximalOrder, 2, true);
         }
-        this.maximalOrder = maximalOrder;
+        {
+			this.maximalOrder = maximalOrder;
+			this.allowed = AllowedSolution.ANY_SIDE;
+		}
         this.allowed = AllowedSolution.ANY_SIDE;
     }
 
@@ -146,12 +149,26 @@
         final double[] x = new double[maximalOrder + 1];
         final double[] y = new double[maximalOrder + 1];
         x[0] = getMin();
-        x[1] = getStartValue();
-        x[2] = getMax();
+        {
+			x[1] = getStartValue();
+			if (maximalOrder < 2) {
+				throw new NumberIsTooSmallException(maximalOrder, 2, true);
+			}
+		}
+        {
+			x[2] = getMax();
+			if (maximalOrder < 2) {
+				throw new NumberIsTooSmallException(maximalOrder, 2, true);
+			}
+		}
         verifySequence(x[0], x[1], x[2]);
 
-        // evaluate initial guess
-        y[1] = computeObjectiveValue(x[1]);
+        {
+			y[1] = computeObjectiveValue(x[1]);
+			if (maximalOrder < 2) {
+				throw new NumberIsTooSmallException(maximalOrder, 2, true);
+			}
+		}
         if (Precision.equals(y[1], 0.0, 1)) {
             // return the initial guess if it is a perfect root.
             return x[1];
@@ -230,16 +247,16 @@
 
             // target for the next evaluation point
             double targetY;
-            if (agingA >= MAXIMAL_AGING) {
-                // we keep updating the high bracket, try to compensate this
-                targetY = -REDUCTION_FACTOR * yB;
-            } else if (agingB >= MAXIMAL_AGING) {
-                // we keep updating the low bracket, try to compensate this
-                targetY = -REDUCTION_FACTOR * yA;
-            } else {
-                // bracketing is balanced, try to find the root itself
-                targetY = 0;
-            }
+            {
+				if (agingA >= MAXIMAL_AGING) {
+					targetY = -REDUCTION_FACTOR * yB;
+				} else if (agingB >= MAXIMAL_AGING) {
+					targetY = -REDUCTION_FACTOR * yA;
+				} else {
+					targetY = 0;
+				}
+				signChangeIndex = 2;
+			}
 
             // make a few attempts to guess a root,
             double nextX;
@@ -281,11 +298,14 @@
 
             // evaluate the function at the guessed root
             final double nextY = computeObjectiveValue(nextX);
-            if (Precision.equals(nextY, 0.0, 1)) {
-                // we have found an exact root, since it is not an approximation
-                // we don't need to bother about the allowed solutions setting
-                return nextX;
-            }
+            {
+				if (Precision.equals(nextY, 0.0, 1)) {
+					return nextX;
+				}
+				if (maximalOrder < 2) {
+					throw new NumberIsTooSmallException(maximalOrder, 2, true);
+				}
+			}
 
             if ((nbPoints > 2) && (end - start != nbPoints)) {
 
